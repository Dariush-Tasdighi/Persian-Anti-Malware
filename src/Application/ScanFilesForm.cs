using System.Linq;

namespace Application;

delegate void SimpleCallback();

public partial class ScanFilesForm : Infrastructure.BaseForm
{
	public ScanFilesForm()
	{
		InitializeComponent();
	}

	private readonly object LockObject = new();

	public string? Path { get; set; }
	private string? CurrentFileScanning { get; set; }

	public long FileCount { get; set; }
	public long DirectoryCount { get; set; }
	public long TotalFileLength { get; set; }
	public long ScannedFileCount { get; set; }
	public long InfectedFileCount { get; set; }

	private System.TimeSpan ScanTimeTaken { get; set; }
	private System.Threading.Thread? GetDirectoriesThread { get; set; }

	private System.Collections.Generic.List<string> Directories { get; set; } = [];
	private System.Collections.Generic.List<string> InfectedFiles { get; set; } = [];

	private void ScanFilesForm_Load
		(object sender, System.EventArgs e)
	{
		stopButton.Enabled = false;
		pauseButton.Enabled = false;

		pathTextBox.Text = Path;
	}

	private void StartButton_Click
		(object sender, System.EventArgs e)
	{
		stopButton.Enabled = true;
		pauseButton.Enabled = true;

		fileCountTextBox.Text = string.Empty;
		currentPathTextBox.Text = string.Empty;
		currentFileTextBox.Text = string.Empty;
		scanTimeTakenTextBox.Text = string.Empty;
		directoryCountTextBox.Text = string.Empty;
		totalFileLengthTextBox.Text = string.Empty;
		scannedFileCountTextBox.Text = string.Empty;
		infectedFileCountTextBox.Text = string.Empty;

		// Solution (1)
		//ScanFiles();
		// /Solution (1)

		// Solution (2)
		var threadStart =
			new System.Threading.ThreadStart(ScanFiles);

		GetDirectoriesThread =
			new System.Threading.Thread(start: threadStart);

		GetDirectoriesThread.Start();
		// /Solution (2)
	}

	private void ScanFiles()
	{
		var stopwatch =
			new System.Diagnostics.Stopwatch();

		stopwatch.Start();

		GetAllDirectories(path: Path);

		stopwatch.Stop();

		ScanTimeTaken = stopwatch.Elapsed;

		DisplayScanTimeTaken();
	}

	/// <summary>
	/// Recursive
	/// </summary>
	private void GetAllDirectories(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return;
		}

		DirectoryCount++;
		DisplayDirectoryCount();
		AddPathToDirectories(path: path);

		UpdateAndDisplayFileCountAndTotalFileLength(path: path);

		var subDirectories =
			GetSubDirectories(path: path);

		if (subDirectories is null)
		{
			return;
		}

		foreach (var item in subDirectories)
		{
			GetAllDirectories(path: item);
		}
	}

	private void AddPathToDirectories(string path)
	{
		lock (LockObject)
		{
			Directories.Add(item: path);
		}
	}

	//private System.Collections.Generic.List<string>? GetCurrentDirectories(string? path)
	//{
	//	if(string.IsNullOrWhiteSpace(value: path))
	//	{
	//		return null;
	//	}

	//	var directoryInfo =
	//		new System.IO.DirectoryInfo(path: path);

	//	var directoryInfos =
	//		directoryInfo.GetDirectories();

	//	var directories =
	//		directoryInfos
	//		.Select(current => current.FullName)
	//		.ToList()
	//		;

	//	return directories;
	//}

	private static System.Collections.Generic.List<string>? GetSubDirectories(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return null;
		}

		var enumerationOptions =
			new System.IO.EnumerationOptions
			{
				BufferSize = 4096,

				IgnoreInaccessible = true,
				RecurseSubdirectories = false,
				//RecurseSubdirectories = true,
				ReturnSpecialDirectories = false, // Not . and ..

				MaxRecursionDepth = int.MaxValue,
				MatchType = System.IO.MatchType.Win32,
				AttributesToSkip = System.IO.FileAttributes.None,
				MatchCasing = System.IO.MatchCasing.PlatformDefault,
			};

		var directories =
			System.IO.Directory.EnumerateDirectories(path: path,
			searchPattern: "*.*", enumerationOptions: enumerationOptions)
			.ToList()
			;

		return directories;
	}

	private static System.Collections.Generic.List<string>? GetFiles(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return null;
		}

		var enumerationOptions =
			new System.IO.EnumerationOptions
			{
				BufferSize = 4096,

				IgnoreInaccessible = true,
				RecurseSubdirectories = false,
				//RecurseSubdirectories = true,
				ReturnSpecialDirectories = false, // Not . and ..

				MaxRecursionDepth = int.MaxValue,
				MatchType = System.IO.MatchType.Win32,
				AttributesToSkip = System.IO.FileAttributes.None,
				MatchCasing = System.IO.MatchCasing.PlatformDefault,
			};

		var directories =
			System.IO.Directory.EnumerateFiles(path: path,
			searchPattern: "*.*", enumerationOptions: enumerationOptions)
			.ToList()
			;

		return directories;
	}

	private void UpdateAndDisplayFileCountAndTotalFileLength(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return;
		}

		var files =
			GetFiles(path: path);

		if (files is null)
		{
			return;
		}

		foreach (var file in files)
		{
			FileCount++;

			var fileInfo =
				new System.IO.FileInfo(fileName: file);

			TotalFileLength += fileInfo.Length;
		}

		DisplayFileCount();
		DisplayTotalFileLength();
	}

	private void DisplayDirectoryCount()
	{
		// Solution (1)
		//directoryCountTextBox.Text =
		//	DirectoryCount.ToString(format: "#,##0");
		// /Solution (1)

		// Solution (2)
		if (directoryCountTextBox.InvokeRequired)
		{
			var callback =
				new SimpleCallback(DisplayDirectoryCount);

			try
			{
				Invoke(method: callback);
			}
			catch { }
		}
		else
		{
			directoryCountTextBox.Text =
				DirectoryCount.ToString(format: "#,##0");
		}
		// /Solution (2)
	}

	private void DisplayFileCount()
	{
		if (fileCountTextBox.InvokeRequired)
		{
			var callback =
				new SimpleCallback(DisplayFileCount);

			try
			{
				Invoke(method: callback);
			}
			catch { }
		}
		else
		{
			fileCountTextBox.Text =
				FileCount.ToString(format: "#,##0");
		}
	}

	private void DisplayTotalFileLength()
	{
		if (totalFileLengthTextBox.InvokeRequired)
		{
			var callback =
				new SimpleCallback(DisplayTotalFileLength);

			try
			{
				Invoke(method: callback);
			}
			catch { }
		}
		else
		{
			totalFileLengthTextBox.Text =
				TotalFileLength.ToString(format: "#,##0 Bytes");
		}
	}

	private void DisplayScanTimeTaken()
	{
		if (scanTimeTakenTextBox.InvokeRequired)
		{
			var callback =
				new SimpleCallback(DisplayScanTimeTaken);

			try
			{
				Invoke(method: callback);
			}
			catch { }
		}
		else
		{
			scanTimeTakenTextBox.Text = ScanTimeTaken.ToString();
		}
	}
}
