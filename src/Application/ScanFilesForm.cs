using System.Linq;

namespace Application;

delegate void SimpleCallback();

public partial class ScanFilesForm : Infrastructure.BaseForm
{
	public ScanFilesForm()
	{
		InitializeComponent();
	}

	private readonly object LockObject = new();

	public string? Path { get; set; }

	private long FileCount { get; set; }
	private long DirectoryCount { get; set; }
	private long ScannedFileCount { get; set; }
	private long TotalFilesLength { get; set; }
	private long InfectedFileCount { get; set; }

	private string? CurrentFileScanning { get; set; }
	private string? CurrentPathScanning { get; set; }

	private System.TimeSpan TotalTimeTaken { get; set; }
	private System.TimeSpan DetectAllDirectoriesTimeTaken { get; set; }

	private System.Threading.Thread? ScanFilesThread { get; set; }
	private System.Threading.Thread? GetDirectoriesThread { get; set; }

	private System.Collections.Generic.List<string> Directories { get; set; } = [];
	public System.Collections.Generic.List<string> InfectedFiles { get; set; } = [];

	private void ScanFilesForm_Load
		(object sender, System.EventArgs e)
	{
		pathTextBox.Text = Path;
	}

	private void StartButton_Click
		(object sender, System.EventArgs e)
	{
		Reset();

		startButton.Enabled = false;

		// **************************************************
		var now =
			System.DateTime.Now.TimeOfDay;

		var idleTimeFrom =
			new System.TimeSpan
			(hours: 1, minutes: 0, seconds: 0);

		var idleTimeTo =
			new System.TimeSpan
			(hours: 4, minutes: 0, seconds: 0);
		// **************************************************

		// **************************************************
		var getDirectoriesThreadStart =
			new System.Threading.ThreadStart(GetAllDirectories);

		GetDirectoriesThread =
			new System.Threading.Thread
			(start: getDirectoriesThreadStart);

		if (now >= idleTimeFrom && now <= idleTimeTo)
		{
			GetDirectoriesThread.Priority =
				System.Threading.ThreadPriority.Highest;
		}
		else
		{
			GetDirectoriesThread.Priority =
				System.Threading.ThreadPriority.Lowest;
		}

		GetDirectoriesThread.Start();
		// **************************************************

		// **************************************************
		var scanFilesThreadStart =
			new System.Threading.ThreadStart(ScanFiles);

		ScanFilesThread =
			new System.Threading.Thread
			(start: scanFilesThreadStart);

		if (now >= idleTimeFrom && now <= idleTimeTo)
		{
			ScanFilesThread.Priority =
				System.Threading.ThreadPriority.Highest;
		}
		else
		{
			ScanFilesThread.Priority =
				System.Threading.ThreadPriority.Lowest;
		}

		ScanFilesThread.Start();
		// **************************************************
	}

	private void Reset()
	{
		// **************************************************
		fileCountTextBox.Text = string.Empty;
		directoryCountTextBox.Text = string.Empty;
		totalTimeTakenTextBox.Text = string.Empty;
		scannedFileCountTextBox.Text = string.Empty;
		totalFilesLengthTextBox.Text = string.Empty;
		infectedFileCountTextBox.Text = string.Empty;
		currentFileScanningTextBox.Text = string.Empty;
		currentPathScanningTextBox.Text = string.Empty;
		detectAllDirectoriesTimeTakenTextBox.Text = string.Empty;
		// **************************************************

		// **************************************************
		FileCount = 0;
		DirectoryCount = 0;
		ScannedFileCount = 0;
		TotalFilesLength = 0;
		InfectedFileCount = 0;

		CurrentFileScanning = null;
		CurrentPathScanning = null;

		TotalTimeTaken = new System.TimeSpan();
		DetectAllDirectoriesTimeTaken = new System.TimeSpan();
		// **************************************************

		// **************************************************
		lock (LockObject)
		{
			Directories.Clear();
			InfectedFiles.Clear();
		}
		// **************************************************
	}

	private void GetAllDirectories()
	{
		var stopwatch =
			new System.Diagnostics.Stopwatch();

		stopwatch.Start();

		GetAllDirectories(path: Path);

		stopwatch.Stop();

		DetectAllDirectoriesTimeTaken = stopwatch.Elapsed;

		Dtat.ThreadSafeHelper.SetControlProperty(control:
			detectAllDirectoriesTimeTakenTextBox, propertyName:
			nameof(detectAllDirectoriesTimeTakenTextBox.Text), propertyValue: DetectAllDirectoriesTimeTaken.ToString());
	}

	private void GetAllDirectories(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return;
		}

		DirectoryCount++;

		Dtat.ThreadSafeHelper.SetControlProperty
			(control: directoryCountTextBox, propertyName:
			nameof(directoryCountTextBox.Text), propertyValue: DirectoryCount.ToString(format: "#,##0"));

		AddCurrentPathToDirectoriesList(path: path);
		UpdateAndDisplayFileCountAndTotalFileLength(path: path);

		var subDirectories =
			GetSubDirectories(path: path);

		if (subDirectories is null)
		{
			return;
		}

		// TODO - Check!
		subDirectories =
			subDirectories
			.OrderBy(current => current)
			.ToList()
			;

		foreach (var item in subDirectories)
		{
			GetAllDirectories(path: item);
		}
	}

	private void AddCurrentPathToDirectoriesList(string path)
	{
		lock (LockObject)
		{
			Directories.Add(item: path);
		}
	}

	private static System.Collections.Generic.List<string>? GetSubDirectories(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return null;
		}

		var enumerationOptions =
			new System.IO.EnumerationOptions
			{
				BufferSize = 4096,

				IgnoreInaccessible = true,
				RecurseSubdirectories = false,
				//RecurseSubdirectories = true,
				ReturnSpecialDirectories = false, // Not (.) and (..)

				MaxRecursionDepth = int.MaxValue,
				MatchType = System.IO.MatchType.Win32,
				AttributesToSkip = System.IO.FileAttributes.None,
				MatchCasing = System.IO.MatchCasing.PlatformDefault,
			};

		var directories =
			System.IO.Directory.EnumerateDirectories(path: path,
			searchPattern: "*.*", enumerationOptions: enumerationOptions)
			.ToList()
			;

		return directories;
	}

	private static System.Collections.Generic.List<string>? GetFiles(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return null;
		}

		var enumerationOptions =
			new System.IO.EnumerationOptions
			{
				BufferSize = 4096,

				IgnoreInaccessible = true,
				RecurseSubdirectories = false,
				//RecurseSubdirectories = true,
				ReturnSpecialDirectories = false, // Not (.) and (..)

				MaxRecursionDepth = int.MaxValue,
				MatchType = System.IO.MatchType.Win32,
				AttributesToSkip = System.IO.FileAttributes.None,
				MatchCasing = System.IO.MatchCasing.PlatformDefault,
			};

		var directories =
			System.IO.Directory.EnumerateFiles(path: path,
			searchPattern: "*.*", enumerationOptions: enumerationOptions)
			.ToList()
			;

		return directories;
	}

	private void UpdateAndDisplayFileCountAndTotalFileLength(string? path)
	{
		if (string.IsNullOrWhiteSpace(value: path))
		{
			return;
		}

		var files =
			GetFiles(path: path);

		if (files is null)
		{
			return;
		}

		foreach (var file in files)
		{
			FileCount++;

			var fileInfo =
				new System.IO.FileInfo(fileName: file);

			TotalFilesLength += fileInfo.Length;
		}

		Dtat.ThreadSafeHelper.SetControlProperty
			(control: fileCountTextBox, propertyName:
			nameof(fileCountTextBox.Text), propertyValue: FileCount.ToString(format: "#,##0"));

		Dtat.ThreadSafeHelper.SetControlProperty
			(control: totalFilesLengthTextBox, propertyName:
			nameof(totalFilesLengthTextBox.Text), propertyValue: TotalFilesLength.ToString(format: "#,##0"));
	}

	public async void ScanFiles()
	{
		var stopwatch =
			new System.Diagnostics.Stopwatch();

		stopwatch.Start();

		System.Threading.Thread.Sleep
			(millisecondsTimeout: 1000);

		var index = 0;

		while (Directories.Count > 0)
		{
			var path =
				Directories[index];

			CurrentPathScanning = path;

			Dtat.ThreadSafeHelper.SetControlProperty
				(control: currentPathScanningTextBox, propertyName:
				nameof(currentPathScanningTextBox.Text), propertyValue: CurrentPathScanning);

			var files =
				GetFiles(path: path);

			if (files is not null)
			{
				foreach (var file in files)
				{
					try
					{
						await ScanFileAsync(pathName: file);

						ScannedFileCount++;

						Dtat.ThreadSafeHelper.SetControlProperty
							(control: scannedFileCountTextBox, propertyName:
							nameof(scannedFileCountTextBox.Text), propertyValue: ScannedFileCount.ToString(format: "#,##0"));
					}
					catch
					{
					}
				}
			}

			lock (LockObject)
			{
				if (Directories.Count > 0)
				{
					Directories.RemoveAt(index: index);
				}
			}
		}

		stopwatch.Stop();

		TotalTimeTaken = stopwatch.Elapsed;

		Dtat.ThreadSafeHelper.SetControlProperty
			(control: totalTimeTakenTextBox, propertyName:
			nameof(totalTimeTakenTextBox.Text), propertyValue: TotalTimeTaken.ToString());

		Dtat.ThreadSafeHelper.SetControlProperty(control:
			startButton, propertyName: nameof(startButton.Enabled), propertyValue: true);
	}

	private async System.Threading.Tasks.Task ScanFileAsync(string pathName)
	{
		Dtat.ThreadSafeHelper.SetControlProperty
			(control: currentFileScanningTextBox, propertyName:
			nameof(currentFileScanningTextBox.Text), propertyValue: pathName);

		var result =
			await
			Infrastructure
			.Utility.GetMD5HashAsync(pathName: pathName);

		if (Infrastructure.MD5Hashes.List.Contains(value: result))
		{
			InfectedFileCount++;

			Dtat.ThreadSafeHelper.SetControlProperty
				(control: infectedFileCountTextBox, propertyName:
				nameof(infectedFileCountTextBox.Text), propertyValue: InfectedFileCount.ToString(format: "#,##0"));

			lock (LockObject)
			{
				InfectedFiles.Add(item: pathName);
			}
		}
	}

	/// <summary>
	/// https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads
	/// </summary>
	private void ScanFilesForm_FormClosed
		(object sender, System.Windows.Forms.FormClosedEventArgs e)
	{
		//if (ScanFilesThread is not null)
		//{
		//	var id =
		//		ScanFilesThread.ManagedThreadId;

		//	System.Diagnostics.Process.GetProcessById
		//		(processId: id).Kill(entireProcessTree: true);
		//}

		//if (GetDirectoriesThread is not null)
		//{
		//	var id =
		//		GetDirectoriesThread.ManagedThreadId;

		//	System.Diagnostics.Process.GetProcessById
		//		(processId: id).Kill(entireProcessTree: true);
		//}
	}
}
